## My OpenBMC userspace development workflow

I recently pushed a couple of tools ([overlay][1] and [bbdbg][2]) into the
[openbmc-tools][3] repository that help me develop userspace software for
OpenBMC. This post describes how I work with all the different tools involved.

Without modifying anything in a stock OpenBMC image, the process to generate the
build artifacts is to issue `bitbake obmc-phosphor-image`. Building a stock
image doesn't help much with developing userspace applications though, so there
needs to be more to the story.

An approach to building specific applications to run in the target environment
generated by `bitbake` is to use the SDK, configuring your shell session so you
can build arbitrary applications for the target. But there are at least two
pitfalls to the SDK: It takes a long time to build and install, and in
OpenBMC's case there's no promise of ABI stability. In general this means
building an SDK that's specific to the state of the target environment, down to
the specific commit the target image was built from.

With those constraints in mind, I prefer to try routes that don't involve the
SDK. `bitbake` is the tool for building the images, so it would be useful if we
could reuse it or its environment. With [`devtool`][4] it turns out we can.
Here's a run-down of the process I follow:

### On the development machine, build a base image on which we'll test our work
1. `cd ~/src/openbmc/openbmc`
2. `. setup p10bmc`
3. `bitbake obmc-phosphor-image`

From here we deploy the resulting image onto the target in the usual fashion.

### On the development machine, set up a repository to work on
4. `cd ~/src/openbmc`
5. `git clone https://github.com/openbmc/dbus-sensors.git`
6. `cd dbus-sensors`
7. `git checkout -b my-hacks`
8. `vi src/NVMeSensorMain.cpp`
9. `git commit -a -m "my hacks"`

In this case we've modified `src/NVMeSensorMain.cpp` which forms part of the
source for the `nvmesensor` application installed into `/usr/bin` on the target.

### On the development machine, configure and build our modified application
10. `devtool modify dbus-sensors`
11. `cd ~/src/openbmc/openbmc/build/p10bmc/workspace/sources/dbus-sensors`
12. `git remote add local ~/src/openbmc/dbus-sensors`
13. `git fetch local my-hacks && git merge FETCH_HEAD`
14. `devtool build dbus-sensors`

### On the target machine, prepare to deploy the modified application
15. `overlay add /usr/bin /lib/systemd/system ...`

For systems with a read-only rootfs, this makes the directory arguments writable
by overlaying them with a `tmpfs`. The `overlay` script handles the grunt work of
setting up the necessary `tmpfs` mountpoints, whose location we don't really
care about in the general case.

The `overlay` script lives [here][1] and should just be copied onto the target
using `scp`.

### From the development machine, deploy the modified application to the target
16. `devtool deploy-target --no-host-check --show-status --no-check-space --strip dbus-sensors`

Note this may require [a rather hacky patch to devtool][5]

### On the target machine, test the modified application and discover issues
17. Test `/usr/bin/nvmesensor`
18. `/usr/bin/nvmesensor` generates a core-dump

### On the target machine, extract the application core dump
19. `coredumpctl dump $PID -o /tmp/core`

### On the development machine, prepare the bitbake environment for core analysis
21. `bitbake -c do_rootfs obmc-phosphor-image`

`devtool build` doesn't run the step of packaging up the application for `opkg`
to deploy and updating the package index, so we have to explicitly invoke this
step ourselves.

### On the development machine, analyse the core dump
22. `scp $BMC:/tmp/core .`
23. `bbdbg ~/src/openbmc/openbmc/build/p10bmc /usr/bin/nvmesensor core dbus-sensors dbus-sensors-dbg`

Using [`bbdbg`][2] we create ourselves a `gdb` session where we can perform
sensible analysis of the `nvmesensor` core with all the necessary symbols loaded
in. The easiest way to access `bbdbg` is to clone the [openbmc-tools
repository][3] onto your development machine.

## Interactive debugging with `gdbserver` and `bbdbg`
If we return to the step 16 where we're testing `nvmesensor` on the target, we
can also do interactive debug rather than core debug if we use `gdbserver` on
the target.

### On the target machine, attach `gdbserver` to a running application
22. `gdbserver --attach localhost:1234 $PID`

Note that `gdbserver` typically ignores the `host` portion of `host:port`, so we
just pick `localhost` here.

### On the development machine, use `bbdbg` to attach to the remote `gdbserver`
23. `bbdbg ~/src/openbmc/openbmc/build/p10bmc /usr/bin/nvmesensor - dbus-sensors dbus-sensors-dbg`
24. `(gdb) target remote $BMC:1234`

[1]: https://github.com/openbmc/openbmc-tools/blob/master/overlay/overlay
[2]: https://github.com/openbmc/openbmc-tools/blob/master/bbdbg/bbdbg
[3]: https://github.com/openbmc/openbmc-tools
[4]: https://docs.yoctoproject.org/singleindex.html#using-devtool-in-your-sdk-workflow
[5]: https://github.com/amboar/openbmc/commit/7d398cd8d0af1c009e6519c74f34a01e2ba923f6
